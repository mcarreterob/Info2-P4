	--P4_modificacion. Hash_Maps_G_Open.		

	function Reads_For_Key (M: in Map; Key: Key_Type) return Natural is
		Index: Hash_Range;
		N: Natural := 1;
		Found: Boolean := False;
	begin
		Index := Hash(Key);
		if M.P_Array(Index).Key = Key then
			N := 1;
			Found := True;
		else
			while Index < Hash_Range'Last and not Found loop 
				Index := Index + 1;
				N := N + 1;
				if M.P_Array(Index).Key = Key then
					Found := True;
				end if;
			end loop;
		end if;
		return N;		
	end Reads_For_Key;

	function Average_Reads_Per_Key(M: Map) return Float is
		F: Float;
		Total: Float := 0.0;
		Index : Hash_Range := 0;
	begin
		while Index < Hash_Range'Last and M.P_Array(Index).Condition /= Empty loop
			F := Float(Reads_For_Key(M,M.P_Array(Index).Key));
			Total := F + Total;
			Index := Index + 1;
		end loop;
		return Total/Float(M.Length);
	end Average_Reads_Per_Key;

	--P3_modificación. Lista Circular.

	function Search (M: Map; Key: Key_Type) return Cursor is
		P_Aux: Cell_A;
		C: Cursor;
		Found: Boolean := False;
	begin
		C.M := M;
		P_Aux := C.M.P_First;
		if P_Aux.Key = Key then
			C.Element_A := P_Aux;
			C.Element_B := C.Element_A;
		else
			while not Found loop
				if P_Aux.Key = Key then
					C.Element_A := P_Aux;
					C.Element_B := C.Element_A;
					Found := True;
				end if;
				P_Aux := P_Aux.Next;
				if P_Aux = C.M.P_First and not Found then
					raise Not_Found;
				end if;
			end loop;
		end if;
		return C;
	end Search;

    procedure Put(M: in out Map; Key: Key_Type; Value: Value_Type) is
        P_Aux: Cell_A;
        P_Aux_2: Cell_A;
        Success: Boolean := False;
		Terminado: Boolean := False;
    begin
		P_Aux := M.P_First;
		P_Aux_2 := M.P_First;
		if M.P_First = null then
			P_Aux := new Cell;
			P_Aux.Key := Key;
			P_Aux.Value := Value;
			M.P_First := P_Aux;
			M.P_Last := P_Aux;
			P_Aux.Next := M.P_First;
			M.Length := M.Length + 1;
		else
			while not Success and not Terminado loop
				if P_Aux.Key = Key then
					P_Aux.Value := Value;
					Success := True;
				end if;
				--Terminado := P_Aux = M.P_Last;
				if P_Aux = M.P_Last then
					Terminado := True;
				end if;
				P_Aux_2 := P_Aux;
				P_Aux := P_Aux.Next;

			end loop;
			if not Success and Terminado then
				P_Aux := new Cell;
				P_Aux.Key := Key;
				P_Aux.Value := Value;
				M.P_Last := P_Aux;
				P_Aux_2.Next := P_Aux;
				P_Aux.Next := M.P_First;
				M.Length := M.Length + 1;
				Success := True;
			end if;
		end if;
    end Put;

    procedure Next (C: in out Cursor) is
    begin
        C.Element_A := C.Element_A.Next;
		if C.Element_A = C.Element_B then
			C.Element_A := null;
		end if;
    end Next;

	--Lista Queue.

 procedure Enqueue(M: in out Map; Key: Key_Type; Value: Value_Type) is
        P_Aux: Cell_A;
        P_Aux_2: Cell_A;
        Success: Boolean := False;
    begin
		P_Aux := M.P_First;
		P_Aux_2 := M.P_First;
		if M.P_First = null then
			P_Aux := new Cell;
			P_Aux.Key := Key;
			P_Aux.Value := Value;
			M.P_First := P_Aux;
		else
			while P_Aux /= null and not Success loop
				if P_Aux.Key = Key then
					P_Aux.Value := Value;
					Success := True;
				end if;
				P_Aux_2 := P_Aux;
				P_Aux := P_Aux.Next;
			end loop;
			if P_Aux = null and not Success then
				P_Aux := new Cell;
				P_Aux.Key := Key;
				P_Aux.Value := Value;
				P_Aux_2.Next := P_Aux;
			end if;
		end if;
    end Enqueue;

    procedure Dequeue(M: in out Map; Key: out Key_Type) is
        P_Aux: Cell_A;
    begin
		P_Aux := M.P_First;
		if M.P_First = null then
			Ada.Text_IO.Put_Line("Lista vacía");
		else
			M.P_First := P_Aux.Next;
			Key := P_Aux.Key;
			Free(P_Aux);
		end if;

    end Dequeue;




